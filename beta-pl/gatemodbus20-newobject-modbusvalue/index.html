<!DOCTYPE html><html lang="pl"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Grenton Sp. z o. o."/><title>Grenton Downloads</title><meta name="twitter:title" content="Grenton Downloads"/><meta name="og:title" content="Grenton Downloads"/><link href="/styles.css" rel="stylesheet"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous"/></head><body class="bg-light"><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-dark" aria-label="Main navigation"><div class="container-fluid"><a class="navbar-brand" href="/release-pl"><img class="glogo" src="/images/logo.svg" alt="logo-grenton" height="18"/></a><span><a style="text-decoration: none;font-size: .835rem; color:#ffffff!important;" href="/beta-en/gatemodbus20-newobject-modbusvalue"><img style="margin-bottom: 3px;" height="16px" src="/images/english.png"/>&nbsp;English</a></span></div></nav><div class="nav-scroller bg-white shadow-sm"><nav class="nav nav-underline" aria-label="Secondary navigation"><a class="nav-link active" aria-current="page" href="/beta-pl">&larr; Powrót</a></nav></div><main class="container"><div class="d-flex align-items-center p-3 my-3 text-white bg-purple rounded shadow-sm"><div class="lh-1"><h1 class="h6 mb-0 text-white lh-1">Konfiguracja obiektu wirtualnego ModbusValue</h1><small>Instrukcja</small></div></div><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Opisany obiekt wirtualny jest dostępny dla <strong>GRENTON GATE MODBUS MASTER, DIN, Eth (INT-201-E-01)</strong> posiadający <strong>firmware 1.1.10-2137E lub wyższy!</strong></small></div><h5>Konfiguracja obiektu wirtualnego ModbusValue</h5><p>Aby użyć obiektu wirtualnego ModbusValue należy:</p><ul><li>Utworzyć obiekt wirtualny <em>ModbusValue</em> i nadać mu nazwę:</li></ul><img src="/images/images-pl/GATE_MODBUS_VALUE_CONFIG_1.png" alt="GATE<em>MODBUS</em>VALUE<em>CONFIG</em>1.png"/><ul><li>Przejść do zakładki <em>Cechy wbudowane</em> i wprowadzić:<ul><li><strong>TransmissionSpeed</strong> – prędkość transmisji;</li><li><strong>Parity</strong> - parametr ustawia sprawdzanie parzystości:<ul><li>0 - None</li><li>1 - Odd</li><li>2 - Even</li></ul></li><li><strong>StopBits</strong> - liczba bitów stopu urządzenia Slave:<ul><li>0 - 1 bit stopu</li><li>1 - 1.5 bitu stopu</li><li>2 - 2 bity stopu</li></ul></li><li><strong>DeviceAddress</strong> – adres urządzenia Slave;</li><li><strong>ResponseTimeout</strong> - czas na odpowiedź w krokach 25ms;</li><li><strong>RefreshPeriod</strong> - minimalny okres odświeżania w krokach 5ms - wartość 0 wyłącza automatyczne odświeżanie;</li><li><strong>RegisterAddress</strong> – adres obsługiwanego rejestru;</li><li><strong>RegisterType</strong> - typ ustawionego rejestru:<ul><li>0 - wyjścia dwustanowe</li><li>1 - wejścia dwustanowe</li><li>2 - rejestry pamiętające</li><li>3 - rejestry wejściowe</li></ul></li><li><strong>Divisor</strong> - dzielnik (skala) wartości;</li><li><strong>InitialValueAccess</strong> - metoda pierwszego dostępu do wartości Value:<ul><li>0 - wartość początkowa Value jest odczytywana z urządzenia;</li><li>1 - wartość początkowa Value jest zapisywana do urządzenia;</li></ul></li></ul></li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Wpisanie wybranej wartości w polu <code>Value</code> przy ustawieniu cechy <code>InitialValueAccess</code>=1 powoduje zapisanie wartości (wysłanie odpowiedniej ramki) po wysłaniu konfiguracji na CLU. Jeśli wartość cechy <code>InitialValueAccess</code>= 0 wpisana wartość w polu <code>Value</code> jest ignorowana.</small></div><ul><li>parametry odpowiednie dla wybranego typu rejestru urządzenia Slave - rozdział <strong>Parametry rejestrów</strong></li></ul><img src="/images/images-pl/GATE_MODBUS_VALUE_CONFIG_2.png" alt="GATE<em>MODBUS</em>VALUE<em>CONFIG</em>2.png"/><ul><li>Wysłać konfigurację oraz zweryfikować połączenie – zakładka <em>Cechy wbudowane</em>, cecha <code>ErrorCode</code>= 0 (poprawny odczyt/zapis):</li></ul><img src="/images/images-pl/GATE_MODBUS_VALUE_CONFIG_3.png" alt="GATE<em>MODBUS</em>VALUE<em>CONFIG</em>3.png"/><h5>Parametry rejestrów</h5><p>W zależności od typu danego rejestru urządzenia Slave, należy ustawić odpowiednio kolejne dostępne parametry.</p><h6>A. 16-bitowe wartości całkowite rejestrów</h6><p>Odczyt 16-bitowych rejestrów pamiętających (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_1.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_1.png"/><p>Odczyt 16-bitowych rejestrów wejściowych (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><p>Zapis 16-bitowych rejestrów pamiętających (<code>Preset/Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><h6>B. Pola w rejestrach 16-bitowych</h6><p>Odczyt pól bitowych w 16-bitowym rejestrze pamiętającym (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 16 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 15 (pozycja pierwszego interesującego bitu).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Zakres liczbowy cechy <code>BitFieldWidth</code> zależy od ustawienia wartości cechy <code>DataWidth</code>. Dla <code>DataWidth</code> = 16 zakres cechy <code>BitFieldWidth</code> wynosi [0 - 16]. W chwili ustawienia cechy <code>BitFieldWidth</code> na wartość równą 0 i wysłaniu konfiguracji cecha przyjmuje wartość maksymalną dla aktualnie ustawionej wartości cechy <code>DataWidth</code>. Zakres liczbowy cechy <code>BitFieldPosition</code> zależy od ustawienia wartości cechy <code>DataWidth</code>. Dla <code>DataWidth</code> = 16 zakres cechy <code>BitFieldWidth</code> wynosi [0 - 15]. Cechy <code>BitFieldWidth</code> i <code>BitFieldPosition</code> są uzależnione od cechy <code>DataWidth</code>. Działają one wg zależności: <code>BitFieldWidth + BitFieldPosition   DataWidth</code> Na przykład: W chwili ustawienia <code>DataWidth</code> i <code>BitFieldWidth</code> = 16 oraz<code>BitFieldPosition</code> = 15 cecha <code>BitFieldWidth</code> automatycznie przyjmie wartość = 1. Dla <code>BitFieldWidth</code>= 0 cecha <code>BitFieldPosition</code> przyjmuje zawsze 0.</small></div><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_2.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_2.png"/><p>Odczyt pól bitowych w 16-bitowym rejestrze wejściowym (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 16 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 15 (pozycja pierwszego interesującego bitu).</li></ul><p>Zapis pól bitowych w 16-bitowym rejestrze pamiętającym (<code>Preset/Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 16 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 15 (pozycja pierwszego interesującego bitu).</li></ul><h6>C. 32-bitowe wartości całkowite rejestrów</h6><p>Odczyt 32-bitowych wartości całkowitych rejestru pamiętającego (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_3.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_3.png"/><p>Odczyt 32-bitowych wartości całkowitych rejestru wejściowego (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><p>Zapis 32-bitowych wartości całkowitych w rejestrze pamiętającym (<code>Preset/Write Multiple Holding Registers</code>, <em>FunctionCode = 16</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><h6>D. Pola w rejestrach 32-bitowych</h6><p>Odczyt pól bitowych w 32-bitowym rejestrze pamiętającym (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 32 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 31 (pozycja pierwszego interesującego bitu).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Zakres liczbowy cechy <code>BitFieldWidth</code> zależy od ustawienia wartości cechy <code>DataWidth</code>. Dla <code>DataWidth</code> = 32 zakres cechy <code>BitFieldWidth</code> wynosi [0 - 32]. W chwili ustawienia cechy <code>BitFieldWidth</code> na wartość równą 0 i wysłaniu konfiguracji cecha przyjmuje wartość maksymalną dla aktualnie ustawionej wartości cechy <code>DataWidth</code>. Zakres liczbowy cechy <code>BitFieldPosition</code> zależy od ustawienia wartości cechy <code>DataWidth</code>. Dla <code>DataWidth</code> = 32 zakres cechy <code>BitFieldWidth</code> wynosi [0 - 31]. Cechy <code>BitFieldWidth</code> i <code>BitFieldPosition</code> są uzależnione od cechy <code>DataWidth</code>. Działają one wg zależności: <code>BitFieldWidth + BitFieldPosition &lt;=  DataWidth</code> Na przykład: W chwili ustawienia <code>DataWidth</code> i <code>BitFieldWidth</code> = 32 oraz<code>BitFieldPosition</code> = 15 cecha <code>BitFieldWidth</code> automatycznie przyjmie wartość = 17. Dla <code>BitFieldWidth</code>= 0 cecha <code>BitFieldPosition</code> przyjmuje zawsze 0.</small></div><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_4.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_4.png"/><p>Odczyt pól bitowych w 32-bitowym rejestrze wejściowym (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 32 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 31 (pozycja pierwszego interesującego bitu).</li></ul><p>Zapis pól bitowych w 16-bitowym rejestrze pamiętającym (<code>Preset/Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 32 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 31 (pozycja pierwszego interesującego bitu).</li></ul><h6>E. 32-bitowe wartości zmiennoprzecinkowe rejestrów</h6><p>Odczyt 32-bitowych wartości zmiennoprzecinkowych rejestru pamiętającego (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Dla <code>DataType</code> = Floating-point cechy <code>BitFieldWidth</code>, <code>BitFieldPosition</code> oraz <code>Divisor</code> są nieaktywne i przyjmują zawsze wartość 0!</small></div><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_5.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_5.png"/><p>Odczyt 32-bitowych wartości zmiennoprzecinkowych rejestru wejściowego (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian.</li></ul><p>Zapis 32-bitowych wartości zmiennoprzecinkowych w rejestrze pamiętającym (<code>Preset/Write Multiple Holding Registers</code>, <em>FunctionCode = 16</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian.</li></ul><h6>F. 64-bitowe wartości całkowite rejestrów</h6><p>Odczyt 64-bitowych rejestrów pamiętających (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_6.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_6.png"/><p>Odczyt 64-bitowych rejestrów wejściowych (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><p>Zapis 64-bitowych rejestrów pamiętających (<code>Preset/Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: wartość domyślna;</li><li><code>BitFieldPosition</code>: wartość domyślna.</li></ul><h6>G. Pola w rejestrach 64-bitowych</h6><p>Odczyt pól bitowych w 64-bitowym rejestrze pamiętającym (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 64 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 63 (pozycja pierwszego interesującego bitu).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Zakres liczbowy cechy <code>BitFieldWidth</code> zależy od ustawienia wartości cechy <code>DataWidth</code>. Dla <code>DataWidth</code> = 64 zakres cechy <code>BitFieldWidth</code> wynosi [0 - 64]. W chwili ustawienia cechy <code>BitFieldWidth</code> na wartość równą 0 i wysłaniu konfiguracji cecha przyjmuje wartość maksymalną dla aktualnie ustawionej wartości cechy <code>DataWidth</code>. Zakres liczbowy cechy <code>BitFieldPosition</code> zależy od ustawienia wartości cechy <code>DataWidth</code>. Dla <code>DataWidth</code> = 64 zakres cechy <code>BitFieldWidth</code> wynosi [0 - 63]. Cechy <code>BitFieldWidth</code> i <code>BitFieldPosition</code> są uzależnione od cechy <code>DataWidth</code>. Działają one wg zależności: <code>BitFieldWidth + BitFieldPosition &lt;=  DataWidth</code> Na przykład: W chwili ustawienia <code>DataWidth</code> i <code>BitFieldWidth</code> = 64 oraz<code>BitFieldPosition</code> = 15 cecha <code>BitFieldWidth</code> automatycznie przyjmie wartość = 49. Dla <code>BitFieldWidth</code>= 0 cecha <code>BitFieldPosition</code> przyjmuje zawsze 0.</small></div><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_7.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_7.png"/><p>Odczyt pól bitowych w 64-bitowym rejestrze wejściowym (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 64 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 63 (pozycja pierwszego interesującego bitu).</li></ul><p>Zapis pól bitowych w 16-bitowym rejestrze pamiętającym (<code>Preset/Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: wartość domyślna;</li><li><code>BitFieldWidth</code>: 0 - 64 (ilość odczytywanych kolejno bitów; dla wartości 0 przyjmowana jest automatycznie szerokość maksymalna = DataWidth);</li><li><code>BitFieldPosition</code>: 0 - 63 (pozycja pierwszego interesującego bitu).</li></ul><h6>H. 64-bitowe wartości zmiennoprzecinkowe rejestrów</h6><p>Odczyt 64-bitowych wartości zmiennoprzecinkowych rejestru pamiętającego (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: Big Endian.</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Dla <code>DataType</code> = Floating-point cechy <code>BitFieldWidth</code>, <code>BitFieldPosition</code> oraz <code>Divisor</code> są nieaktywne i przyjmują zawsze wartość 0!</small></div><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_6.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_8.png"/><p>Odczyt 64-bitowych wartości zmiennoprzecinkowych rejestru wejściowego (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: Big Endian.</li></ul><p>Zapis 64-bitowych wartości zmiennoprzecinkowych w rejestrze pamiętającym (<code>Preset/Write Multiple Holding Registers</code>, <em>FunctionCode = 16</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: Big Endian.</li></ul><h6>J. Dyskretne wejścia/wyjścia</h6><p>Odczyt dyskretnych wyjść/wejść bitowych (<code>Read Coil Status</code>, <em>FunctionCode = 01</em>):</p><ul><li><code>RegisterType</code>: Discrete outputs / coils;</li><li><code>InputOutputCount</code>: 1 - 64 (liczba dyskretnych wejść/wyjść podlegających operacji odczytu/zapisu).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">UWAGA!</b><br>Dla typów rejestrów <em>Discrete outputs / coils</em> i <em>Discrete Inputs</em> cechy <code>DataType</code>,<code>DataWidth</code>, <code>Endianness</code>, <code>BitFieldWidth</code>, <code>BitFieldPosition</code>, <code>Divisor</code> są nieaktywne i przyjmują wartość 0!</small></div><img src="/images/images-pl/GATE_MODBUS_VALUE_REGISTERS_PARAM_9.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_9.png"/><p>Odczyt dyskretnych wejść dwustanowych (<code>Read Discrete Inputs</code>, <em>FunctionCode = 02</em>):</p><ul><li><code>RegisterType</code>: Discrete Inputs;</li><li><code>InputOutputCount</code>: 1 - 64 (liczba dyskretnych wejść/wyjść podlegających operacji odczytu/zapisu).</li></ul><p>Zapis dyskretnych wyjść/wejść bitowych (<code>Force/Write Single Coil</code>, <em>FunctionCode = 05</em>; <code>Force/Write Multiple Coils</code>, <em>FunctionCode = 15</em>):</p><ul><li><code>RegisterType</code>: Discrete outputs / coils;</li><li><code>InputOutputCount</code>: 1 - 64 (liczba dyskretnych wejść/wyjść podlegających operacji odczytu/zapisu).</li></ul><h5>Parametry konfiguracyjne</h5><p><strong>CECHY</strong></p><table class="table table-bordered w-75 mx-auto d-block d-md-table"><thead><tr><th>Nazwa</th><th>Opis</th></tr></thead><tbody><tr><td><code>TransmissionSpeed</code></td><td>Prędkość transmisji</td></tr><tr><td><code>Parity</code></td><td>Bit parzystości:<br/>&#13; 0 - None<br/>&#13; 1 - Odd<br/>&#13; 2 - Even</td></tr><tr><td><code>StopBits</code></td><td>Bity stopu:<br/>&#13; 0 - 1 bit stopu<br/>&#13; 1 - 1.5 bitu stopu<br/>&#13; 2 - 2 bity stopu</td></tr><tr><td><code>DeviceAddress</code></td><td>Adres urządzenia Slave Modbus</td></tr><tr><td><code>ResponseTimeout</code></td><td>Czas na odpowiedź w krokach 25ms</td></tr><tr><td><code>RefreshPeriod</code></td><td>Minimalny okres odświeżania w krokach 5ms. Wartość 0 wyłącza automatyczne odświeżanie</td></tr><tr><td><code>RegisterAddress</code></td><td>Adres obsługiwanego rejestru</td></tr><tr><td><code>RegisterType</code></td><td>Typ rejestru Modbus (0 – wejścia/wyjścia bitowe, 1 – wejścia dwustanowe, 2 – rejestry pamiętające, 3 – rejestry wejściowe)</td></tr><tr><td><code>InputOutputCount</code></td><td>Określa liczbę dyskretnych wejść/wyjść podlegających operacji odczytu/zapisu</td></tr><tr><td><code>DataType</code></td><td>Typ wartości:<br />0 - Liczba całkowita, stałoprzecinkowa lub pole bitowe bez bitu znaku<br />1 - Liczba całkowita, stałoprzecinkowa lub pole bitowe z bitem znaku<br />2 - Liczba zmiennoprzecinkowa</td></tr><tr><td><code>DataWidth</code></td><td>Szerokość danych (od 1 do 4 rejestrów 16 bitowych)</td></tr><tr><td><code>Endianness</code></td><td>Kolejność bajtów:<br />0 - kolejność słów: Big Endian; kolejność bajtów w słowie: Big Endian<br />1 - kolejność słów: Little Endian; kolejność bajtów w słowie: Big Endian<br />2 - kolejność słów: Big Endian; kolejność bajtów w słowie: Little Endian<br />3 - kolejność słów: Little Endian; kolejność bajtów w słowie: Little Endian</td></tr><tr><td><code>BitFieldWidth</code></td><td>Liczba bitów pola bitowego. Suma BitFieldWidth i Position powinna być &lt;= DataWidth; 0 oznacza brak pola bitowego (pełna szerokość danych = DataWidth)</td></tr><tr><td><code>BitFieldPosition</code></td><td>Pozycja najmłodszego bitu pola bitowego. Suma BitFieldWidth i Position powinna być &lt;= DataWidth.</td></tr><tr><td><code>Divisor</code></td><td>Dzielnik (skala) wartości</td></tr><tr><td><code>InitialValueAccess</code></td><td>Metoda pierwszego dostępu do wartości Value:<br/>&#13;0 - wartość początkowa Value jest odczytywana z urządzenia<br/>1 - wartość początkowa Value jest zapisywana do urządzenia</td></tr><tr><td><code>Value</code></td><td>Zwraca ostatnio odczytaną wartość oraz określa wartość początkową</td></tr><tr><td><code>RawValue</code></td><td>Nieprzeskalowana wartość rejestru</td></tr><tr><td><code>IsValueValid</code></td><td>Określa, czy wartość jest zgodna ze stanem obiektu</td></tr><tr><td><code>ErrorCode</code></td><td>Kod błędu:<br />1 – niedozwolona funkcja<br/>&#13;2 – niedozwolony numer rejestru<br/>&#13;3 – niedozwolona wartość danej<br/>&#13;4 – uszkodzenie w przyłączonym urządzeniu<br/>&#13;5 – potwierdzenie pozytywne<br/>&#13;6 – brak gotowości, komunikat usunięty<br/>&#13;7 – potwierdzenie negatywne<br />&#13;8 – błąd parzystości pamięci<br/>&#13;0 - poprawny odczyt/zapis rejestru<br/>&#13;-2 - przekroczenie czasu odpowiedzi<br/>&#13;-3 - błąd ramki (problem ze zdekodowaniem odpowiedzi)<br />&#13;-4 - nieoczekiwany rozmiar odpowiedzi<br/>&#13;-5 - nieoczekiwany kod odpowiedzi</td></tr></tbody></table><p><strong>METODY</strong></p><table class="table table-bordered w-75 mx-auto d-block d-md-table"><thead><tr><th>Nazwa</th><th>Opis</th></tr></thead><tbody><tr><td><code>SetTransmissionSpeed</code></td><td>Ustawia prędkość transmisji</td></tr><tr><td><code>SetParity</code></td><td>Ustawia sprawdzanie parzystości</td></tr><tr><td><code>SetStopBits</code></td><td>Ustawia liczbę bitów stopu</td></tr><tr><td><code>SetDeviceAddress</code></td><td>Ustawia adres urządzenia Modbus typu Slave</td></tr><tr><td><code>SetResponseTimeout</code></td><td>Ustawia czas przekroczenia odpowiedzi w krokach 25ms</td></tr><tr><td><code>SetRefreshPeriod</code></td><td>Ustawia okres odświeżania w krokach 5ms - wartość 0 wyłącza automatyczne odświeżanie</td></tr><tr><td><code>SetRegisterAddress</code></td><td>Ustawia adres obsługiwanego rejestru</td></tr><tr><td><code>SetRegisterType</code></td><td>Ustawia typ rejestru Modbus</td></tr><tr><td><code>SetInputOutputCount</code></td><td>Ustawia liczbę dyskretnych wejść / wyjść podlegających operacji odczytu / zapisu</td></tr><tr><td><code>SetDataType</code></td><td>Ustawia typ zmiennej</td></tr><tr><td><code>SetDataWidth</code></td><td>Ustawia szerokość danych</td></tr><tr><td><code>SetEndianness</code></td><td>Ustawia typ kolejności bajtów</td></tr><tr><td><code>SetBitFieldWidth</code></td><td>Ustawia liczbę bitów pola - 0 oznacza brak pola bitowego (pełna szerokość danych DataWidth)</td></tr><tr><td><code>SetBitFieldPosition</code></td><td>Ustawia pozycję najmłodszego bitu pola</td></tr><tr><td><code>SetDivisor</code></td><td>Ustawia dzielnik</td></tr><tr><td><code>ReadValue</code></td><td>Rozpoczyna odczyt wartości z urządzenia - czeka na zakończenie odczytu w przypadku braku OnValueRead</td></tr><tr><td><code>WriteValue</code></td><td>Zapisuje nową wartość do urządzenia</td></tr></tbody></table><p><strong>ZDARZENIA</strong></p><table class="table table-bordered w-75 mx-auto d-block d-md-table"><thead><tr><th>Nazwa</th><th>Opis</th></tr></thead><tbody><tr><td><code>OnValueChange</code></td><td>Zdarzenie wywoływane w przypadku zmiany wartości cechy Value lub zmiany parametrów obiektu</td></tr><tr><td><code>OnValueRead</code></td><td>Zdarzenie wywoływane po zakończeniu odczytu rozpoczętego przez metodę ReadValue</td></tr><tr><td><code>OnError</code></td><td>Zdarzenie wywoływane gdy urządzenie slave zgłasza błąd</td></tr></tbody></table><nav class="navbar navbar-light bg-light gfooter"><div class="container-fluid"><span class="navbar-text"><small>&copy; 2024 Grenton Sp. z o. o.</small></span></div></nav></main></body></html>