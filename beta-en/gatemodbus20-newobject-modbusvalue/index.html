<!DOCTYPE html><html lang="pl"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Grenton Sp. z o. o."/><title>Grenton Downloads</title><meta name="twitter:title" content="Grenton Downloads"/><meta name="og:title" content="Grenton Downloads"/><link href="/styles.css" rel="stylesheet"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous"/></head><body class="bg-light"><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-dark" aria-label="Main navigation"><div class="container-fluid"><a class="navbar-brand" href="/release-en"><img class="glogo" src="/images/logo.svg" alt="logo-grenton" height="18"/></a><span><a style="text-decoration: none;font-size: .835rem; color:#ffffff!important;" href="/beta-pl/gatemodbus20-newobject-modbusvalue"><img style="margin-bottom: 3px;" height="16px" src="/images/polski.png"/>&nbsp;Polski</a></span></div></nav><div class="nav-scroller bg-white shadow-sm"><nav class="nav nav-underline" aria-label="Secondary navigation"><a class="nav-link active" aria-current="page" href="/beta-en">&larr; Back</a></nav></div><main class="container"><div class="d-flex align-items-center p-3 my-3 text-white bg-purple rounded shadow-sm"><div class="lh-1"><h1 class="h6 mb-0 text-white lh-1">ModbusValue virtual object configuration</h1><small>Tutorial</small></div></div><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>The described virtual object is available for <strong>GRENTON GATE MODBUS MASTER, DIN, Eth (INT-201-E-01)</strong> with <strong>firmware 1.1.10 or higher!</strong></small></div><h5>ModbusValue virtual object configuration</h5><p>To use the ModbusValue virtual object:</p><ul><li>Create a virtual object <em>ModbusValue</em> and name it:</li></ul><img src="/images/images-eng/GATE_MODBUS_VALUE_CONFIG_1.png" alt="GATE<em>MODBUS</em>VALUE<em>CONFIG</em>1.png"/><ul><li>Go to <em>Embedded features</em> tab and enter:<ul><li><strong>TransmissionSpeed</strong> - transmission speed;</li><li><strong>Parity</strong> - sets the parity check:<ul><li>0 - None</li><li>1 - Odd</li><li>2 - Even</li></ul></li><li><strong>StopBits</strong> - sets the number of stop bits:<ul><li>0 - 1 stop bit</li><li>1 - 1.5 stop bits</li><li>2 - 2 stop bits</li></ul></li><li><strong>DeviceAddress</strong> - address of the slave device;</li><li><strong>ResponseTimeout</strong> - response timeout in 25ms steps;</li><li><strong>RefreshPeriod</strong> - minimum refresh period in 5ms steps - 0 means automatic refresh is disabled;</li><li><strong>RegisterAddress</strong> - address of the supported registry;</li><li><strong>RegisterType</strong> - type of the register set:<ul><li>0 - Discrete outputs / coils</li><li>1 - Discrete inputs</li><li>2 - Holding registers</li><li>3 - Input registers</li></ul></li><li><strong>Divisor</strong> - value divisor (scale);</li><li><strong>InitialValueAccess</strong> - initial Value access method:<ul><li>0 - The initial Value and SetValue parameter are sent to the device;</li><li>1 - The initial Value and SetValue parameter are ignored the method of first accessing to the value;</li></ul></li></ul></li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>Entering a value in <code>Value</code> field when setting the <code>InitialValueAccess</code> = 1 feature causes saving the value (sending the appropriate frame) after sending the configuration to the CLU. If the value of the <code>InitialValueAccess</code> = 0 feature, the entered value in <code>Value</code> field is ignored.</small></div><ul><li>parameters appropriate for the selected slave device type - chapter <strong>Parameters of registers</strong></li></ul><img src="/images/images-eng/GATE_MODBUS_VALUE_CONFIG_2.png" alt="GATE<em>MODBUS</em>VALUE<em>CONFIG</em>2.png"/><ul><li>Send configuration and verify connection - tab <em>Embedded features</em>, feature <code>ErrorCode</code> = 0 (correct read / write):</li></ul><img src="/images/images-eng/GATE_MODBUS_VALUE_CONFIG_3.png" alt="GATE<em>MODBUS</em>VALUE<em>CONFIG</em>3.png"/><h5>Parameters of registers</h5><p>Depending on the type of Slave register, the next available parameters must be set accordingly.</p><h6>A. 16-bit integer values of registers</h6><p>Reading 16-bit holding registers (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_1.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_1.png"/><p>Reading 16-bit input registers (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><p>Records of 16-bit holding registers (<code>Preset / Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><h6>B. Fields in 16-bit registers</h6><p>Reading of bit fields in a 16-bit remembering register (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 16 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 15 (position of the first interesting bit).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>The range of the <code>BitFieldWidth</code> feature depends on the setting of the value of the <code>DataWidth</code> feature. For <code>DataWidth</code> = 16, the range of the <code>BitFieldWidth</code> feature is [0 - 16]. At the moment of setting the <code>BitFieldWidth</code> feature to 0 and sending the configuration, the feature takes the maximum value for the currently set value of the <code>DataWidth</code> feature. The range of the <code>BitFieldPosition</code> feature depends on the setting of the value of the <code>DataWidth</code> feature. For <code>DataWidth</code> = 16, the range of the <code>BitFieldWidth</code> feature is [0 - 15]. The <code>BitFieldWidth</code> and <code>BitFieldPosition</code> features are dependent on the <code>DataWidth</code> feature according to the condition: <code>BitFieldWidth + BitFieldPosition  DataWidth</code>. For example: When setting <code>DataWidth</code> and <code>BitFieldWidth</code> = 16 and <code>BitFieldPosition</code> = 15, the <code>BitFieldWidth</code> will automatically be set to = 1. For <code>BitFieldWidth</code> = 0, the <code>BitFieldPosition</code> attribute is always 0.</small></div><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_2.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_2.png"/><p>Reading of bit fields in a 16-bit input register (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 16 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 15 (position of the first interesting bit).</li></ul><p>Writing bit fields in a 16-bit reminder register (<code>Preset / Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 16;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 16 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 15 (position of the first interesting bit).</li></ul><h6>C. 32-bit integer values of registers</h6><p>Reading 32-bit integer values of the retaining register (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_3.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_3.png"/><p>Reading 32-bit integer values of the input register (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><p>Writing of 32-bit integers in the remembering register (<code>Preset / Write Multiple Holding Registers</code>, <em>FunctionCode = 16</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><h6>D. Fields in 32-bit registers</h6><p>Reading of bit fields in a 32-bit remembering register (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 32 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 31 (position of the first interesting bit).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>The range of the <code>BitFieldWidth</code> feature depends on the setting of the value of the <code>DataWidth</code> feature. For <code>DataWidth</code> = 32, the range of the <code>BitFieldWidth</code> feature is [0 - 32]. At the moment of setting the <code>BitFieldWidth</code> feature to 0 and sending the configuration, the feature takes the maximum value for the currently set value of the <code>DataWidth</code> feature. The range of the <code>BitFieldPosition</code> feature depends on the setting of the value of the <code>DataWidth</code> feature. For <code>DataWidth</code> = 32, the range of the <code>BitFieldPosition</code> feature is [0 - 31]. The <code>BitFieldWidth</code> and <code>BitFieldPosition</code> features are dependent on the <code>DataWidth</code> feature according to the condition: <code>BitFieldWidth + BitFieldPosition  DataWidth</code>. For example: When setting <code>DataWidth</code> and <code>BitFieldWidth</code> = 32 and <code>BitFieldPosition</code> = 15, the <code>BitFieldWidth</code> will automatically be set to = 17. For <code>BitFieldWidth</code> = 0, the <code>BitFieldPosition</code> attribute is always 0.</small></div><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_4.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_4.png"/><p>Reading of bit fields in a 32-bit input register (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 32 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 31 (position of the first interesting bit).</li></ul><p>Writing bit fields in a 32-bit reminder register (<code>Preset / Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 32 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 31 (position of the first interesting bit).</li></ul><h6>E. 32-bit floating point values of registers</h6><p>Reading of the 32-bit floating point values of the remembering register (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian.</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>For <code>DataType</code> = Floating-point, the <code>BitFieldWidth</code>, <code>BitFieldPosition</code> and <code>Divisor</code> features are inactive and are always 0!</small></div><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_5.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_5.png"/><p>Reading of 32-bit floating point register values (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian.</li></ul><p>Record of 32-bit floating point values in the reminder register (<code>Preset / Write Multiple Holding Registers</code>, <em>FunctionCode = 16</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 32;</li><li><code>Endianness</code>: Big Endian.</li></ul><h5>F. 64-bit integer values of registers</h5><p>Reading 64-bit holding registers (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_6.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_6.png"/><p>Reading 64-bit input registers (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><p>Records of 64-bit holding registers (<code>Preset / Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: default value;</li><li><code>BitFieldPosition</code>: default value.</li></ul><h6>G. Fields in 64-bit registers</h6><p>Reading of bit fields in a 64-bit remembering register (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 64 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 63 (position of the first interesting bit).</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>The range of the <code>BitFieldWidth</code> feature depends on the setting of the value of the <code>DataWidth</code> feature. For <code>DataWidth</code> = 64, the range of the <code>BitFieldWidth</code> feature is [0 - 64]. At the moment of setting the <code>BitFieldWidth</code> feature to 0 and sending the configuration, the feature takes the maximum value for the currently set value of the <code>DataWidth</code> feature. The range of the <code>BitFieldPosition</code> feature depends on the setting of the value of the <code>DataWidth</code> feature. For <code>DataWidth</code> = 64, the range of the <code>BitFieldPosition</code> feature is [0 - 63]. The <code>BitFieldWidth</code> and <code>BitFieldPosition</code> features are dependent on the <code>DataWidth</code> feature according to the condition: <code>BitFieldWidth + BitFieldPosition  DataWidth</code>. For example: When setting <code>DataWidth</code> and <code>BitFieldWidth</code> = 60 and <code>BitFieldPosition</code> = 15, the <code>BitFieldWidth</code> will automatically be set to = 49. For <code>BitFieldWidth</code> = 0, the <code>BitFieldPosition</code> attribute is always 0.</small></div><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_7.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_7.png"/><p>Reading of bit fields in a 64-bit input register (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 64 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 63 (position of the first interesting bit).</li></ul><p>Writing bit fields in a 64-bit reminder register (<code>Preset / Write Single Holding Register</code>, <em>FunctionCode = 06</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Unsigned Integer;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: default value;</li><li><code>BitFieldWidth</code>: 0 - 64 (number of bits read sequentially);</li><li><code>BitFieldPosition</code>: 0 - 63 (position of the first interesting bit).</li></ul><h6>H. 64-bit floating point values of registers</h6><p>Reading of the 64-bit floating point values of the remembering register (<code>Read Holding Registers</code>, <em>FunctionCode = 03</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: Big Endian.</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>For <code>DataType</code> = Floating-point, the <code>BitFieldWidth</code>, <code>BitFieldPosition</code> and <code>Divisor</code> features are inactive and are always 0!</small></div><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_6.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_8.png"/><p>Reading of 64-bit floating point register values (<code>Read Input Registers</code>, <em>FunctionCode = 04</em>):</p><ul><li><code>RegisterType</code>: Input Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: Big Endian.</li></ul><p>Record of 64-bit floating point values in the reminder register (<code>Preset / Write Multiple Holding Registers</code>, <em>FunctionCode = 16</em>):</p><ul><li><code>RegisterType</code>: Holding Registers;</li><li><code>DataType</code>: Floating-point;</li><li><code>DataWidth</code>: 64;</li><li><code>Endianness</code>: Big Endian.</li></ul><h6>J. Discrete inputs / outputs</h6><p>Readout of discrete outputs / bit inputs (<code>Read Coil Status</code>, <em>FunctionCode = 01</em>):</p><ul><li><code>RegisterType</code>: Discrete outputs / coils;</li><li><code>InputOutputCount</code>: 1 - 64 (number of discrete inputs / outputs subject to read / write operations);</li></ul><div class="alert alert-warning" role="alert"><small><b class="uwaga">NOTE!</b><br>For the <code>Discrete outputs / coils</code> and <code>Discrete Inputs</code> register types the features <code>DataType</code>, <code>DataWidth</code>, <code>Endianness</code>, <code>BitFieldWidth</code>, <code>BitFieldPosition</code>, <code>Divisor</code> are inactive and always have the value 0!</small></div><img src="/images/images-eng/GATE_MODBUS_VALUE_REGISTERS_PARAM_9.png" alt="GATE<em>MODBUS</em>VALUE<em>REGISTERS</em>PARAM_9.png"/><p>Readout of discrete binary inputs (<code>Read Discrete Inputs</code>, <em>FunctionCode = 02</em>):</p><ul><li><code>RegisterType</code>: Discrete Inputs;</li><li><code>InputOutputCount</code>: 1 - 64 (number of discrete inputs / outputs subject to read / write operations);</li><li><code>InitialValueAccess</code>: Read.</li></ul><p>Writing of discrete outputs / bit inputs (<code>Force / Write Single Coil</code>, <em>FunctionCode = 05</em>; <code>Force / Write Multiple Coils</code>, <em>FunctionCode = 15</em>):</p><ul><li><code>RegisterType</code>: Discrete outputs / coils;</li><li><code>InputOutputCount</code>: 1 - 64 (number of discrete inputs / outputs subject to read / write operations);</li><li><code>InitialValueAccess</code>: Write.</li></ul><h5>Configuration parameters</h5><p><strong>FEATURES</strong></p><table class="table table-bordered w-75 mx-auto d-block d-md-table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>TransmissionSpeed</code></td><td>Transmission Speed</td></tr><tr><td><code>Parity</code></td><td>Parity bit: <br/> 0 - None <br/> 1 - Odd <br/> 2 - Even</td></tr><tr><td><code>StopBits</code></td><td>Stop bits: <br/> 0 - 1 stop bit <br/> 1 - 1.5 stop bits <br/> 2 - 2 stop bits</td></tr><tr><td><code>DeviceAddress</code></td><td>Address of the Slave Modbus device</td></tr><tr><td><code>ResponseTimeout</code></td><td>Response timeout in 25ms steps</td></tr><tr><td><code>RefreshPeriod</code></td><td>Minimum refresh period in 5ms steps. 0 means automatic refresh is disabled</td></tr><tr><td><code>RegisterAddress</code></td><td>Address of the supported registry</td></tr><tr><td><code>RegisterType</code></td><td>Modbus register type (0 - Discrete outputs / coils, 1 - Discrete inputs, 2 - Holding registers, 3 - Input registers)</td></tr><tr><td><code>InputOutputCount</code></td><td>Specifies the number of discrete I / O that can be read / written</td></tr><tr><td><code>DataType</code></td><td>Value type:<br />0 - An integer, a fixed-point number or a bit field without a sign bit<br />1 - An integer, a fixed-point number or a bit field with a sign bit<br />2 - A floating-point number</td></tr><tr><td><code>DataWidth</code></td><td>Data width (from 1 to 4 16-bit registers)</td></tr><tr><td><code>Endianness</code></td><td>Endianness:<br />0 - Big Endian order of words; Big Endian order of bytes in a word<br />1 - Little Endian order of words; Big Endian order of bytes in a word<br />2 - Big Endian order of words; Little Endian order of bytes in a word<br />3 - Little Endian order of words; Little Endian order of bytes in a word</td></tr><tr><td><code>BitFieldWidth</code></td><td>The number of bits in the bit field. The sum of BitFieldWidth and Position should be &lt;= DataWidth; 0 means no bit field (full data width = DataWidth)</td></tr><tr><td><code>BitFieldPosition</code></td><td>The position of the youngest bit of the bit field. The sum of BitFieldWidth and Position should be &lt;= DataWidth.</td></tr><tr><td><code>Divisor</code></td><td>Divisor</td></tr><tr><td><code>InitialValueAccess</code></td><td>Initial Value access method:<br/>0 - The initial Value is read from the device<br/>1 - The initial Value is written to the device</td></tr><tr><td><code>Value</code></td><td>Returns the last value read and specifies the initial value</td></tr><tr><td><code>RawValue</code></td><td>Unscaled register value</td></tr><tr><td><code>IsValueValid</code></td><td>Determines whether a value matches the state of an object</td></tr><tr><td><code>ErrorCode</code></td><td>Error code:<br/>&#13;1 – illegal function<br/>&#13;2 – illegal register number<br/>&#13;3 – illegal data value<br/>&#13;4 – connected device damaged<br/>&#13;5 – positive confirmation<br/>&#13;6 – no readiness, message removed<br/>&#13;7 – negative confirmation<br/>&#13;8 – memory parity error<br/>&#13;0 - correct read/write register<br/>&#13;-2 - exceeding the response timeout<br/>&#13;-3 - frame error (error decoding the frame)<br/>&#13;-4 - unexpected reply size<br/>&#13;-5 - unexpected reply code</td></tr></tbody></table><p><strong>METHODS</strong></p><table class="table table-bordered w-75 mx-auto d-block d-md-table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>SetTransmissionSpeed</code></td><td>Sets transmission speed</td></tr><tr><td><code>SetParity</code></td><td>Sets parity check type</td></tr><tr><td><code>SetStopBits</code></td><td>Sets stop bit count</td></tr><tr><td><code>SetDeviceAddress</code></td><td>Sets Modbus slave device address</td></tr><tr><td><code>SetResponseTimeout</code></td><td>Sets the response timeout in 25ms steps</td></tr><tr><td><code>SetRefreshPeriod</code></td><td>Sets the refresh period in 5ms steps. 0 means automatic refresh is disabled</td></tr><tr><td><code>SetRegisterAddress</code></td><td>Sets the supported register address</td></tr><tr><td><code>SetRegisterType</code></td><td>Sets the modbus register type</td></tr><tr><td><code>SetInputOutputCount</code></td><td>Sets the number of discrete IOs to be read / written</td></tr><tr><td><code>SetDataType</code></td><td>Sets the variable type</td></tr><tr><td><code>SetDataWidth</code></td><td>Sets the data width</td></tr><tr><td><code>SetEndianness</code></td><td>Sets byte order</td></tr><tr><td><code>SetBitFieldWidth</code></td><td>Sets the bit field width. 0 means no bit field (full DataWidth)</td></tr><tr><td><code>SetBitFieldPosition</code></td><td>Sets the starting position of the bit field</td></tr><tr><td><code>SetDivisor</code></td><td>Sets the divisor</td></tr><tr><td><code>ReadValue</code></td><td>Starts reading from the device. Waits for completion in case of no OnValueRead</td></tr><tr><td><code>WriteValue</code></td><td>Writes a new value to the device</td></tr></tbody></table><p><strong>EVENTS</strong></p><table class="table table-bordered w-75 mx-auto d-block d-md-table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>OnValueChange</code></td><td>Event occurring after the feature value has been changed or the object parameters have changed</td></tr><tr><td><code>OnValueRead</code></td><td>Event occurring after the read started by the ReadValue method completes</td></tr><tr><td><code>OnError</code></td><td>Event occurring when the slave device reports an error</td></tr></tbody></table><nav class="navbar navbar-light bg-light gfooter"><div class="container-fluid"><span class="navbar-text"><small>&copy; 2025 Grenton Sp. z o. o.</small></span></div></nav></main></body></html>